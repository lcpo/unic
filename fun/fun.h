#ifndef _UNIC_C_STRUCTURE_FUNCTION
#define _UNIC_C_STRUCTURE_FUNCTION
typedef uni * (*func)(uni *p,...);
typedef uni * object,Object,class,Class,new,obj,Obj,function;

static func * 	fun_$;  		//! адрес функции
static char ** 	fun_$n; 		//! название функции
static uni  * 	fun_$o;			//! то что возвращает функция
static uni  * 	fun_$p;			//! функция прородитель, в случае первичной является родителем себя самой:)
static uni  * 	fun_$a;			//! Количество аргументов|-1 бесконечное
static uni 		fun_$l; 		//! количество записей
static char *** fun_$i;			//! Синонимы функции
#endif
#include "arg/arg.c" //Требуется в переборке и оптимизации
/*!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Релиз функций/макросов для работы с функциями, редакция 13.01.13
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!*/
///todo
///1. написать выгрузку методов по объекту родителю
///2. написать наследование и замену методов (Полиморфизм)
///3. написать ассоциатор (прогроматор) типов данных
///4. написать очистку и выгрузку переменных
///5. написать очистку и выгрузку типов данных
///6. написать инкапсуляцию методов										
///7. написать ассoциатор имен методов 									(написано)
///8. написать очистку и выгрузку методов
///Так же желательно организовать авто инициализацию стуктур переменных типов и функций

/*!
 *TODO: Реализовать вызов функции через объект, добавить доступность
 *  Реализовать проверку по родителю
 * Реализовать вызов фукции вида class.func(arg,arg2) (Возможно через временную структуру) class - имя временной структуры, func имя функции вызова (Если получится) 
 * Запихать все фукции в объекты
 * Сделать массив глобальных фукций
 */
#define obj($_p...)({(obj)arg((void*)$_p);})                			///создание массива аргуметов для объекта
///---------------------------------------------------------------------
#define set_fun($_addr,$_type,$_parent,$_narg)({                               \
set_fun_item((func)&$_addr,#$_addr,#$_type,(uni)$_parent,($_narg)?$_narg:-1);  \
})                                                        ///регистрация адреса функции
														  ///$_parent должен быть необязательный параметр добавляющий родителем добавляемую функцию для сокращения кода
//----------------------------------------------------------------------
#define new($_addr,$_type,$_p...)({                                     \
set_fun_item((func)&$_addr,#$_addr,#$_type,(uni)$_addr,-1);              \
($_type)(*$_addr)($_p);})                                  ///Регистрация и вызов объекта
///---------------------------------------------------------------------
#define proc($_type,$_f,$_p...)({										\
set_type_item(#$_type);													\
uni $_addr=get_fun_name(#$_f);											\
func $_call=(func)$_addr;												\
($_type)$_call(arg($_p));												\
}) 															//!не документирована
//----------------------------------------------------------------------
#define fun($_type,$_f,$_p...)({										\
uni $_addr=get_fun_name(#$_f);											\
func $_call=(func)$_addr;												\
($_type)$_call((uni*)$_p);												\
})														  //!Вызывет вложенную зарегистрированную функцию

#define call($_par,$_f,$_type,$_p...)({									\
uni $_addr_par=get_fun_name(#$_par);									\
uni $_addr=get_fun_name(#$_f);											\
})
///---------------------------------------------------------------------add fun alias
#define proto($_name,$_add_name)(set_fun_proto(#$_name,#$_add_name)) ///производит аналогию между основным именем и добавляет дополнительное	
